-- File auto generated by purescript-bridge! --
module JsonHelpers.Types where

import Prelude

import Control.Lazy (defer)
import Data.Argonaut (encodeJson, jsonNull)
import Data.Argonaut.Aeson.Decode.Generic (genericDecodeAeson)
import Data.Argonaut.Aeson.Encode.Generic (genericEncodeAeson)
import Data.Argonaut.Aeson.Options (defaultOptions) as Argonaut
import Data.Argonaut.Decode.Aeson ((</$\>), (</*\>), (</\>))
import Data.Argonaut.Decode.Aeson as D
import Data.Argonaut.Decode.Class (class DecodeJson, class DecodeJsonField, decodeJson)
import Data.Argonaut.Decode.Class as Argonaut
import Data.Argonaut.Encode.Aeson ((>$<), (>/\<))
import Data.Argonaut.Encode.Aeson as E
import Data.Argonaut.Encode.Class (class EncodeJson, encodeJson)
import Data.Argonaut.Encode.Class as Argonaut
import Data.Bounded.Generic (genericBottom, genericTop)
import Data.Either (Either)
import Data.Enum (class Enum)
import Data.Enum.Generic (genericPred, genericSucc)
import Data.Generic.Rep (class Generic)
import Data.Lens (Iso', Lens', Prism', iso, lens, prism')
import Data.Lens.Iso.Newtype (_Newtype)
import Data.Lens.Record (prop)
import Data.Map
import Data.Map as Map
import Data.Maybe (Maybe(..))
import Data.Newtype (class Newtype, unwrap)
import Data.Show.Generic (genericShow)
import Data.Tuple.Nested ((/\))
import Foreign.Object (Object)
import Type.Proxy (Proxy(Proxy))

newtype Baz = Baz { _bazMessage :: String }

instance EncodeJson Baz where
  encodeJson = defer \_ -> E.encode $ unwrap >$< (E.record
                                                 { _bazMessage: E.value :: _ String })

instance DecodeJson Baz where
  decodeJson = defer \_ -> D.decode $ (Baz <$> D.record "Baz" { _bazMessage: D.value :: _ String })



instance Show Baz where
  show a = genericShow a

derive instance Generic Baz _

derive instance Newtype Baz _

--------------------------------------------------------------------------------

_Baz :: Iso' Baz {_bazMessage :: String}
_Baz = _Newtype

bazMessage :: Lens' Baz String
bazMessage = _Newtype <<< prop (Proxy :: _"_bazMessage")

--------------------------------------------------------------------------------

data ID a = ID

-- instance (EncodeJson a) => EncodeJson (ID a) where
--   encodeJson = defer \_ -> E.encode E.enum

-- instance (DecodeJson a, DecodeJsonField a) => DecodeJson (ID a) where
--   decodeJson = defer \_ -> D.decode D.enum



instance Show (ID a) where
  show a = genericShow a

derive instance Generic (ID a) _

-- instance Enum (ID a) where
--   succ = genericSucc
--   pred = genericPred

-- instance Bounded (ID a) where
--   bottom = genericBottom
--   top = genericTop

--------------------------------------------------------------------------------

_ID :: forall a. Iso' (ID a) Unit
_ID = iso (const unit) (const ID)

--------------------------------------------------------------------------------

newtype ID2 a = ID2 { getID :: Int }

instance (EncodeJson a) => EncodeJson (ID2 a) where
  encodeJson = defer \_ -> E.encode $ unwrap >$< (E.record
                                                 { getID: E.value :: _ Int })

instance (DecodeJson a, DecodeJsonField a) => DecodeJson (ID2 a) where
  decodeJson = defer \_ -> D.decode $ (ID2 <$> D.record "ID2" { getID: D.value :: _ Int })



instance Show (ID2 a) where
  show a = genericShow a

derive instance Generic (ID2 a) _

derive instance Newtype (ID2 a) _

--------------------------------------------------------------------------------

_ID2 :: forall a. Iso' (ID2 a) {getID :: Int}
_ID2 = _Newtype

--------------------------------------------------------------------------------

newtype Foo = Foo
  { _fooMessage :: String
  , _fooE :: Either String Int
  , _fooNumber :: Int
  , _fooList :: Array Int
  , _fooMap :: Object Int
  , _fooBaz :: Baz
  , _fooTestSum :: TestSum
  , _fooTestData :: TestData
  }

instance EncodeJson Foo where
  encodeJson = defer \_ -> E.encode $ unwrap >$< (E.record
                                                   { _fooMessage: E.value :: _ String
                                                   , _fooE: (E.either E.value E.value) :: _ (Either String Int)
                                                   , _fooNumber: E.value :: _ Int
                                                   , _fooList: E.value :: _ (Array Int)
                                                   , _fooMap: E.value :: _ (Object Int)
                                                   , _fooBaz: E.value :: _ Baz
                                                   , _fooTestSum: E.value :: _ TestSum
                                                   , _fooTestData: E.value :: _ TestData
                                                   })

instance DecodeJson Foo where
  decodeJson = defer \_ -> D.decode $ (Foo <$> D.record "Foo"
      { _fooMessage: D.value :: _ String
      , _fooE: (D.either D.value D.value) :: _ (Either String Int)
      , _fooNumber: D.value :: _ Int
      , _fooList: D.value :: _ (Array Int)
      , _fooMap: D.value :: _ (Object Int)
      , _fooBaz: D.value :: _ Baz
      , _fooTestSum: D.value :: _ TestSum
      , _fooTestData: D.value :: _ TestData
      })



instance Show Foo where
  show a = genericShow a

derive instance Generic Foo _

derive instance Newtype Foo _

--------------------------------------------------------------------------------

_Foo :: Iso' Foo {_fooMessage :: String, _fooE :: Either String Int, _fooNumber :: Int, _fooList :: Array Int, _fooMap :: Object Int, _fooBaz :: Baz, _fooTestSum :: TestSum, _fooTestData :: TestData}
_Foo = _Newtype

fooMessage :: Lens' Foo String
fooMessage = _Newtype <<< prop (Proxy :: _"_fooMessage")

fooE :: Lens' Foo (Either String Int)
fooE = _Newtype <<< prop (Proxy :: _"_fooE")

fooNumber :: Lens' Foo Int
fooNumber = _Newtype <<< prop (Proxy :: _"_fooNumber")

fooList :: Lens' Foo (Array Int)
fooList = _Newtype <<< prop (Proxy :: _"_fooList")

fooMap :: Lens' Foo (Object Int)
fooMap = _Newtype <<< prop (Proxy :: _"_fooMap")

fooBaz :: Lens' Foo Baz
fooBaz = _Newtype <<< prop (Proxy :: _"_fooBaz")

fooTestSum :: Lens' Foo TestSum
fooTestSum = _Newtype <<< prop (Proxy :: _"_fooTestSum")

fooTestData :: Lens' Foo TestData
fooTestData = _Newtype <<< prop (Proxy :: _"_fooTestData")

--------------------------------------------------------------------------------

newtype Bar a = Bar a

instance (EncodeJson a) => EncodeJson (Bar a) where
  encodeJson = defer \_ -> E.encode $ unwrap >$< E.value

instance (DecodeJson a, DecodeJsonField a) => DecodeJson (Bar a) where
  decodeJson = defer \_ -> D.decode $ (Bar <$> D.value)



instance (Show a) => Show (Bar a) where
  show a = genericShow a

derive instance Generic (Bar a) _

derive instance Newtype (Bar a) _

--------------------------------------------------------------------------------

_Bar :: forall a. Iso' (Bar a) a
_Bar = _Newtype

--------------------------------------------------------------------------------

data TestSum
  = Nullary
  | Bool Boolean
  | Int Int
  | Number Number

instance EncodeJson TestSum where
  encodeJson = defer \_ -> case _ of
    Nullary -> encodeJson { tag: "Nullary", contents: jsonNull }
    Bool a -> E.encodeTagged "Bool" a E.value
    Int a -> E.encodeTagged "Int" a E.value
    Number a -> E.encodeTagged "Number" a E.value

instance DecodeJson TestSum where
  decodeJson = defer \_ -> D.decode
    $ D.sumType "TestSum" $ Map.fromFoldable
      [ "Nullary" /\ pure Nullary
      , "Bool" /\ D.content (Bool <$> D.value)
      , "Int" /\ D.content (Int <$> D.value)
      , "Number" /\ D.content (Number <$> D.value)
      ]



instance Show TestSum where
  show a = genericShow a

derive instance Generic TestSum _

--------------------------------------------------------------------------------

_Nullary :: Prism' TestSum Unit
_Nullary = prism' (const Nullary) case _ of
  Nullary -> Just unit
  _ -> Nothing

_Bool :: Prism' TestSum Boolean
_Bool = prism' Bool case _ of
  (Bool a) -> Just a
  _ -> Nothing

_Int :: Prism' TestSum Int
_Int = prism' Int case _ of
  (Int a) -> Just a
  _ -> Nothing

_Number :: Prism' TestSum Number
_Number = prism' Number case _ of
  (Number a) -> Just a
  _ -> Nothing

--------------------------------------------------------------------------------

data TestData
  = TMaybe (Maybe TestSum)
  | TEither String

instance EncodeJson TestData where
  encodeJson = defer \_ -> case _ of
    TMaybe a -> E.encodeTagged "TMaybe" a (E.maybe E.value)
    TEither a -> E.encodeTagged "TEither" a E.value

instance DecodeJson TestData where
  decodeJson = defer \_ -> D.decode
    $ D.sumType "TestData" $ Map.fromFoldable
      [ "TMaybe" /\ D.content (TMaybe <$> (D.maybe D.value))
      , "TEither" /\ D.content (TEither <$> D.value)
      ]



instance Show TestData where
  show a = genericShow a

derive instance Generic TestData _

--------------------------------------------------------------------------------

_TMaybe :: Prism' TestData (Maybe TestSum)
_TMaybe = prism' TMaybe case _ of
  (TMaybe a) -> Just a
  _ -> Nothing

_TEither :: Prism' TestData String
_TEither = prism' TEither case _ of
  (TEither a) -> Just a
  _ -> Nothing
